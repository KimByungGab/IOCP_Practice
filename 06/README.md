## 변경된 점
1. Send 전담 쓰레드와 큐를 NetworkCore 클래스로 옮겼다.
2. Send 전담 큐의 자료구조를 기존에는 deque이었지만 좀 더 명확히 하기 위하여 queue로 변경
3. 패킷의 멤버변수 중 char배열을 string으로 변경

## 예제와 다른 점
예제에서는 패킷을 담는 deque와 deque에 패킷이 있을 경우 SendMsg를 호출하는 쓰레드가 있으며(기존), ClientInfo마다 Send를 담당하는 queue가 존재한다.<br>
그리고 Send를 한번 진행하면 나머지 담겨있는 모든것들을 다 Send 할 수 있도록 자동으로 ClientInfo의 Send 담당 queue를 전부 비우면서 Send를 한다.

하지만 지금으로서는 순차적으로 Send를 하기위해 나는 예제처럼 2개를 이용하지 않고 하나로만 처리를 하였다. 실상 바뀐 것은 4단계와 다른것이 없다.<br>
그렇다면 왜 이 구조를 유지해두었냐고 생각을 할 수 있다.

그 이유는 다음과 같다.<br>
1. 기존의 예제는 ClientInfo의 queue에 넣어두고 Send를 처리하는것이었다. 하지만 이것은 지금 만들고있는 나의 설계(NetworkCore가 중앙에서 처리하는 방식. 나머지 ClientInfo, Packet 등의 클래스는 단지 Sub의 영역일 뿐.)와는 맞는 구조가 아니다. 때문에 필연적으로 4단계 이후로부터는 예제와 조금 구조가 달라질 수 밖에 없다.
2. 어차피 Send를 하기 위해서는 예제에서도 그랬듯이 패킷 큐에 패킷을 넣어야되고 거기에서 꺼내서 SendMsg를 호출한다. 그렇다면 결국 2개로 나눠쓰나 하나로 사용하나 나의 설계에서는 똑같이 행동하는거나 다름이 없다. 때문에 이왕 진행하는 거 차라리 하나로 진행하는 것이 맞다고 판단했다.
3. 그렇다면 마지막으로 ClientInfo에서는 각 객체마다의 쓰레드를 SendIO 함수를 호출하는데 그게 더 이득일 수 있지 않냐고 물어볼 수 있다. 하지만 내 생각으로는 만약에 경합조건으로 인해 속도에서 문제가 발생한다면 SendIO보다 기존의 deque에서 발생하는 경합에서 이기는 것이 더 어려울것이다. 때문에 결국 내 설계에는 지금과 같은 구조가 맞다고 판단한다.

## 왜 5단계는 하지 않았는가
간단한 이유인데 개인적으로 버퍼보다 큐가 더 직관적이라고 판단했다.<br>
버퍼와 같은 스트림적인 영역을 담당하면서 버퍼의 현재사이즈를 +하고 -하고 등등의 연산을 통해서 관리를 진행하는것보다 딱 나누어떨어진 오브젝트로 두는 것이 훨씬 직관적이라고 생각이 들었기 때문이다.

## 내 생각
아마 지금 현재로서는 다음에 이어지는 AcceptEx까지 완료된다면 모든 요청은 이제 비동기로 이루어질것이다.<br>
이 이후로는 아마 IOCP의 기존 골자들은 끝났고 채팅서버와 같이 컨텐츠를 붙이는 방법과 DB를 연동하는 방법, 그리고 가장 중요하다고 생각하는 패킷이 들어올 때 어떤 요청인지를 구분할 수 있는 방법을 알아봐야겠다.<br>
기존에 몸담고있던 웹분야는 URL로 요청에 관한 분류가 이미 명확하게 되어있기 때문에 자원을 받는 방법(DTO) 등만 잘 만들어두면 나머지는 일사천리였다.<br>
지금은 이제 그 분배가 되는 방법을 내가 직접 만들어야되는것이라고 생각이 든다.<br>
거의 기본적으로는 다 끝난 것 같다.

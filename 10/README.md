## 변경된 점
1. 방 생성, 입장, 퇴장 기능 추가
2. 패킷 직렬화로 패킷 버퍼 등 날것의 패킷이 아닌 구조화된 패킷 구조 추가

## 왜 이번엔 갑자기 10으로 넘어갔나
원래는 8번을 진행해야되는데, 어차피 기능이 생기는것이라면 10번은 그의 연장선인 기능 n개를 추가하는 것이기 때문에 한번에 하는 것이 낫겠다고 생각했다.<br>
하지만 아쉽게도 9번은 넣지 않았다. DB는 따로 사용법만 보여주는 식으로 작업할 생각이다.<br>
이유는 사실
1. Redis보다 더 기본적으로 RDBMS를 사용하고싶었다.
2. 로컬 RDBMS를 사용하게 되면 결국 스키마부터 전부 다 로컬하게 진행되기 때문에 해당 DB가 없으면 이 프로그램은 아예 진행할 수 없다.

## 지금까지 진행하면서 가장 어려웠던 점
1. 락을 언제 걸지, 혹은 어느 순간에 걸어야 가장 효율적인지에 대한 판단.
2. 패킷 버퍼관리... 버퍼 관리를 대충했다가 터져서 3일동안 밥먹고 디버깅만했다.

## 내 생각
드디어 구조를 만들어 기능까지 수행하는 IOCP 서버를 만들어냈다.<br>
이제서야 내가 가장 익숙하게 만졌던 웹서버의 기능처럼 기능별로 수행가능해졌다.

나한테 가장 익숙했던 서버인 웹서버로 비유하자면 Native한 웹서버를 만들어가는 느낌이라고 생각이 든다.<br>
하지만 여기에 Apache 혹은 nginx 서버와 같은 웹 서버의 기능도 만드는 느낌이 되었다.

웹 서버도 수많은 패킷들이 들어올것이다. 단지 포트를 우리가 익히 알고있는 80번 포트로 받거나 프록시를 이용하여 포트를 옮겨줄 뿐.<br>
지금까지는 그저 요청은 요청일 뿐, 어차피 결국 Apache서버가 다 알아서 해결해주는 거 아니겠나. 나는 결국 기능에만 집중하면 돼. 라고 생각했었다.<br>
게다가 그 웹서버의 특징으로 Stateless하기 때문에 상태를 계속 들고있지 않아도 된다는 것도 한몫했다. 기껏 State를 확인해봤자 웹서버에서 말하는 세션의 역할이 그나마 비슷할텐데 그것도 결국 소켓 서버의 완전한 Stateful과는 거리가 다소 멀다.<br>
아니면 가장 비슷한 것을 찾아보라고 하면 웹소켓을 예로 들 수 있겠다. 양방향 통신을 할 수 있는 소켓 계열이기 때문이다. 하지만 이것도 결국 패킷의 헤더에 관한 부분은 HTTP를 사용하는 웹소켓과 달리 TCP계열에서는 직접 만들어야 되는 것이기 때문에 하나부터 모든것을 커스터마이징한다는 점이 특징이었다. 물론 웹 기반인지 아닌지도 차이의 여부이긴 하다 ㅋㅋ

하나부터 열가지 모든것들을 다 처음부터 만들어야되는 IOCP 서버는 막상 코드의 줄 수는 적을지라도 그 코드 안에 있는 개념들은 전부 심오했다.<br>
학부생때의 시절을 되돌아보고 다시 만들어가보며 그대로만 따라하는 것이 아닌 내 방식, 내가 원하는 구조로 커스터마이징해서 나의 것으로 받아들이기 위해 다시 머리를 들이받은 결과 처음에 만들었던 동기적인 서버에서 사이즈가 커지기 때문에 네트워크의 라이브러리를 만들기 시작했고, 시대의 흐름을 따라 비동기적으로 돌아가는 것을 원하여 IOCP와 같은 서버를 원하게 되는 흐름을 알게 되고 왜 이런 흐름으로 발전했는지 이해하게 되었다.

학부생때부터 항상 느껴왔던거지만 TCP/IP 소켓 프로그래밍의 책을 보면 항상 IOCP 혹은 epoll을 만들고나서 끝이 나게 된다. 맨 처음은 몰랐었다.<br>
'왜 기본 골자만 알려주고 바로 끝나는거지? 프레임워크의 책들같은 경우는 그렇다고 해도 하다못해 Node.js에서도 뭐 라우팅하는 방법, exception이 일어났을 때 관리하는 법 등등을 알려주는것들이 많았는데 왜 소켓 프로그래밍의 책들은 다 기본에서 끝나는걸까?'<br>
이 생각이 정말 많이 들었었다. 하지만 기본적인 IOCP가 아닌 기능을 추가해보자마자 알게되었다.<br>

말 그대로 만들기 원하는 스펙(MMORPG, 실시간 턴제 등등)들이 서로마다 다른데, 이 스펙들이 HTTP처럼 스펙이 정해져있는 것이 아니라 패킷 헤더들부터 전부 다 다르구나. 즉, HTTP처럼 통일된 기술이 없으니 자유로운것이고, 그 자유로움때문에 어떤 것이든 답이 될 수 있는것이다. 때문에 이 분야는 모든것을 다 처음부터 스스로 만드는 것이 발달되어 온 것이다.

라고 답을 얻어냈다. 물론 틀린 답일 수도 있다. 하지만 지금으로서의 내가 생각할때는 이것때문이라고 판단된다.

## 더 나아간다면 뭐가 좋을까?
1. DisconnectEx 사용: 일전에도 언급했었던 DisconnectEx를 이용하여 소켓 재사용과 연결 비동기를 챙겨가는 것을 생각해볼법하다.
2. Ring buffer: 지금 사용하는 패킷버퍼는 터지기 직전에 남은 데이터들을 다시 맨 처음으로 옮겨서 다시 사용했다. 그것은 버퍼의 시점에서보면 맨 마지막의 버퍼에 가까울수록 잘 쓰이지가 않는 공간이 되는것이다. Ring buffer는 이 단점을 극복하기 위한 방법이라고 생각한다.

혹여나 여기까지 봐주신 모든 분들, 진심을 다해 감사합니다.<br>
그리고 다시한번 이 경험을 제공해주신 최흥배(https://github.com/jacking75) 님께 진심으로 감사드립니다.
